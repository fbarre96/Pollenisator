"""A plugin to parse a CrackMapExex scan"""

import re
from pollenisator.core.components.tag import Tag
from pollenisator.core.models.ip import Ip
from pollenisator.core.models.port import Port
from pollenisator.server.modules.activedirectory.computers import Computer
from pollenisator.plugins.plugin import Plugin


def getInfos(runfinger_file):
    r"""Read the given runfinger output file results and return a dictionnary with ips and a list of their open ports and infos.
        Args:
            runfinger_file:  the path to the .txt file generated by an runfinger.
        Returns:
            infos array, notes

    File example:
[SMB2]:['10.10.11.129', Os:'Windows 10/Server 2016/2019 (check build)', Build:'17763', Domain:'SEARCH', Bootime: 'Unknown', Signing:'True', RDP:'False', SMB1:'False', MSSQL:'False']
[SMB2]:['10.10.11.147', Os:'Other than Microsoft', Build:'0', Domain:'', Bootime: 'Unknown', Signing:'True', RDP:'False', SMB1:'False', MSSQL:'False']
[SMB2]:['10.10.11.152', Os:'Windows 10/Server 2016/2019 (check build)', Build:'17763', Domain:'TIMELAPSE', Bootime: 'Unknown', Signing:'True', RDP:'False', SMB1:'False', MSSQL:'False']
"""
    retour = []
    regex_info = re.compile(r"^\[SMB\d\]:\['(\S+)', Os:'([^']+)', Build:'(\d+)', Domain:'([^']*)', Bootime: '[^']+', Signing:'(\S+)', RDP:'(\S+)', SMB1:'(\S+)', MSSQL:'(\S+)'\]$", re.MULTILINE)
    
    notes = ""
    countFound = 0
    oneLine = False
    for line in runfinger_file:
        oneLine = True
        if isinstance(line, bytes):
            try:
                line = line.decode("utf-8", errors="ignore")
            except UnicodeDecodeError:
                return None, None
        # Search ip in file
        if line.strip() == "":
            continue
        infos = re.search(regex_info, line)
        if infos is None:
            return None, None # not runfinger
        toAdd = {}
        toAdd["ip"] = infos.group(1)
        toAdd["os"] = infos.group(2)
        toAdd["build"] = infos.group(3)
        toAdd["domain"] = infos.group(4)
        toAdd["signing"] = infos.group(5)
        toAdd["rdp"] = infos.group(6)
        toAdd["smbv1"] = infos.group(7)
        retour.append(toAdd)
    if not oneLine:
        return None, None
    notes = f"Host found : {len(retour)}\n"+notes
    return retour,  notes


def editScopeIPs(pentest, hostsInfos):
    """
    Add all the ips and theirs ports found after parsing the file to the scope object in database.
    Args:
        hostsInfos: the dictionnary with ips as keys and a list of dictionnary containing ports informations as value.
    """
    # Check if any ip has been found.
    targets = {}
    if hostsInfos is not None:
        for infos in hostsInfos:
            infosToAdd = {}
            thisOS = infos.get("os", "")
            if thisOS != "":
                infosToAdd["os"] = thisOS
            build = infos.get("build", "")
            if build != "":
                infosToAdd["build"] = build
            SMBv1 = infos.get("smbv1", "")
            if SMBv1 != "":
                infosToAdd["smbv1"] = SMBv1
            signing = infos.get("signing", "")
            if signing != "":
                infosToAdd["signing"] = signing
            domain = infos.get("domain", "")
            if domain != "":
                infosToAdd["domain"] = domain
            rdp = infos.get("rdp", "")
            if rdp != "":
                infosToAdd["rdp"] = rdp
            mssql = infos.get("mssql", "")
            if mssql != "":
                infosToAdd["mssql"] = mssql
            ip_m = Ip(pentest).initialize(str(infos["ip"]), infos={"plugin":RunFinger.get_name()})
            insert_ret = ip_m.addInDb()
            if not insert_ret["res"]:
                ip_m = Ip.fetchObject(pentest, {"_id": insert_ret["iid"]})
            host = str(infos["ip"])
            port = str(445)
            proto = "tcp"
            service = "netbios-ssn"
            port_m = Port(pentest).initialize(host, port, proto, service, infos={"plugin":RunFinger.get_name()})
            insert_ret = port_m.addInDb()
            port_m = Port.fetchObject(pentest, {"_id": insert_ret["iid"]})
            port_m.updateInfos(infosToAdd)
            computer_m = Computer.fetchObject(pentest, {"ip":port_m.ip})
            if computer_m is not None:
                computer_m.domain = infos.get("domain")
                d = computer_m.getData()
                comp_info = d["infos"]
                comp_info.update(infosToAdd)
                computer_m = Computer(pentest, d)
                computer_m.update()
            targets[str(insert_ret["iid"])] = {
                    "ip": host, "port": port, "proto": proto}
    return targets

class RunFinger(Plugin):
    """Inherits Plugin
    A plugin to parse a runfinger scan"""
    default_bin_names = ["runfinger", "runfinger.py"]
    def getFileOutputArg(self):
        """Returns the command line paramater giving the output file
        Returns:
            string
        """
        return " | tee "

    def getFileOutputExt(self):
        """Returns the expected file extension for this command result file
        Returns:
            string
        """
        return ".log.txt"

    def getFileOutputPath(self, commandExecuted):
        """Returns the output file path given in the executed command using getFileOutputArg
        Args:
            commandExecuted: the command that was executed with an output file inside.
        Returns:
            string: the path to file created
        """
        return commandExecuted.split(self.getFileOutputArg())[-1].strip().split(" ")[0]

    def getTags(self):
        """Returns a list of tags that can be added by this plugin
        Returns:
            list of strings
        """
        return {"info-runfinger": Tag("info-runfinger")}

    def Parse(self, pentest, file_opened, **kwargs):
        """
        Parse a opened file to extract information
       
        Args:
            file_opened: the open file
            kwargs: not used
        Returns:
            a tuple with 4 values (All set to None if Parsing wrong file): 
                0. notes: notes to be inserted in tool giving direct info to pentester
                1. tags: a list of tags to be added to tool 
                2. lvl: the level of the command executed to assign to given targets
                3. targets: a list of composed keys allowing retrieve/insert from/into database targerted objects.
        """
        notes = None
        tags = []
        hostsInfos, notes = getInfos(file_opened)
        if hostsInfos is None:
            return None, None, None, None
        if hostsInfos:
            tags += [Tag(self.getTags()["info-runfinger"], notes=notes)]
        targets = editScopeIPs(pentest, hostsInfos)
        return notes, tags, "ports", targets
