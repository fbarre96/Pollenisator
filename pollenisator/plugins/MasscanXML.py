"""A plugin to parse masscan XML scan"""
import shlex
from defusedxml import ElementTree as ET 
from pollenisator.core.components.tag import Tag
from pollenisator.core.models.ip import Ip
from pollenisator.core.models.port import Port
from pollenisator.plugins.plugin import Plugin
from pollenisator.core.components.logger_config import logger

def getIpPortsMasscan(pentest, scanFile):
    """
        Args:
            scanFile:  the path to the .xml file generated by a masscan scan

        Returns:
            notes about inseted ip and ports
    """
    notes = ""
    countOpen = 0
    ports_to_add = []
    ips_to_add = []
    try:
        tree = ET.parse(scanFile)
        root = tree.getroot()
        scan_info = {
            'scanner': root.get('scanner',""),
            'arguments': root.get('args', ""),
            'start_time': root.get('startstr',""),
            'masscan_version': root.get('version',""),
            'xml_output_version': root.get('xmloutputversion',"")
        }
        if " -sP " in scan_info['arguments']:
            keep_only_open = False
        if scan_info['scanner'] != 'masscan':
            logger.error("Not a masscan scan")
            return None

        for host in root.findall('host'):
            addedIps = []
            addr = host.find('address').get('addr')
            if len(ips_to_add) >= 10000:
                bulk_insertions(pentest, ips_to_add, ports_to_add)
                ips_to_add = []
                ports_to_add = []
            notes_ip = "ip:" + \
                str(addr) if addr!= "" and addr is not None else ""

            ipCIDR_m = Ip(pentest, {"in_scopes":[]}).initialize(str(addr), notes=notes_ip, in_scopes=[], infos={"plugin":MasscanXML.get_name()})
            ips_to_add.append(ipCIDR_m)     
            addedIps.append(ipCIDR_m)
            ports = host.find('ports').findall('port')
            for port in ports:
                port_info = {
                    'protocol': port.get('protocol', "tcp"),
                    'portid': port.get('portid')
                }
                state = port.find('state')
                port_info["state"] = "closed"
                if state is not None:
                    port_info["state"] = state.get("state", "closed")
                service = port.find('service')
                if service is None:
                    port_info['service'] = "unknown"
                    port_info['method'] = ""
                    port_info['product'] = ""
                    port_info['version'] = ""
                else:
                    port_info['service'] = service.get('name', "unknown")
                    port_info['method'] = service.get('method', "")
                    port_info['product'] = service.get('product', "")
                    port_info['version'] = service.get('version', "")
                if port_info['state'] != 'open':
                    continue
                countOpen += 1
                for ip in addedIps:
                    product = port_info.get("product", "")
                    if  product != "" and port_info.get("version", "") != "":
                        product = product + " "+port_info.get("version", "")
                    port_o = Port(pentest).initialize(ip.ip, port_info["portid"], port_info["protocol"], port_info["service"], product, infos={"plugin":MasscanXML.get_name()})
                    ports_to_add.append(port_o)
    except ET.ParseError:
        logger.error("Error parsing masscan xml file")
        return None
    
    bulk_insertions(pentest, ips_to_add, ports_to_add)
    notes = str(countOpen)+" open ports found\n"+notes
    return notes

def bulk_insertions(pentest, ips_to_add, ports_to_add):
    """Bulk insertions of ips and ports
    """
    Ip.bulk_insert(pentest, ips_to_add, look_scopes=True)
    results = Port.bulk_insert(pentest, ports_to_add)
    
class MasscanXML(Plugin):
    default_bin_names = ["masscan"]
    def getFileOutputArg(self):
        """Returns the command line paramater giving the output file
        Returns:
            string
        """
        return " -oX "

    def getFileOutputExt(self):
        """Returns the expected file extension for this command result file
        masscan EXPECT .xml but -oX will append it
        Returns:
            string
        """
        return ".xml"

    def getFileOutputPath(self, commandExecuted):
        """Returns the output file path given in the executed command using getFileOutputArg
        Args:
            commandExecuted: the command that was executed with an output file inside.
        Returns:
            string: the path to file created
        """
        return (commandExecuted.split(self.getFileOutputArg())[-1].strip().split(" ")[0])

    def changeCommand(self, command, outputDir, toolname):
        """
        Summary: Complete the given command with the tool output file option and filename absolute path.
        Args:
            * command : the command line to complete
            * outputDir : the directory where the output file must be generated
            * toolname : the tool name (to be included in the output file name)
        Return:
            The command completed with the tool output file option and filename absolute path.
        """
        #Â default is append at the end
        if self.getFileOutputArg() not in command:
            parts = shlex.split(command) 
            parts.insert(1, self.getFileOutputArg()+outputDir+toolname)
            return " ".join(parts)
        return command

    def getTags(self):
        """Returns a list of tags that can be added by this plugin
        Returns:
            list of strings
        """
        return {"info-masscan": Tag("info-masscan", level="info")}

    def Parse(self, pentest, file_opened, **kwargs):
        """
        Parse a opened file to extract information
        Args:
            file_opened: the open file
            kwargs: 
                "tool" -> ToolModel if file is associated with a tool
                "cmdline" -> if cmdline was given , the command line runned to get this
        Returns:
            a tuple with 4 values (All set to None if Parsing wrong file): 
                0. notes: notes to be inserted in tool giving direct info to pentester
                1. tags: a list of tags to be added to tool 
                2. lvl: the level of the command executed to assign to given targets
                3. targets: a list of composed keys allowing retrieve/insert from/into database targerted objects.
        """
        if kwargs.get("ext", "").lower() != self.getFileOutputExt():
            return None, None, None, None
        tags = [self.getTags()["info-masscan"]]
        notes = getIpPortsMasscan(pentest, file_opened)
        if notes is None:
            return None, None, None, None
        return notes, tags, "scope", {}
