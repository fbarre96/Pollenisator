"""A plugin to parse a CrackMapExex scan"""

import re

from bson import ObjectId
from pollenisator.core.components.tag import Tag
from pollenisator.server.servermodels.ip import ServerIp
from pollenisator.server.servermodels.port import ServerPort
from pollenisator.server.modules.activedirectory.computers import Computer

from pollenisator.server.modules.activedirectory.users import User
from pollenisator.plugins.plugin import Plugin

def remove_term_colors(data):
    return re.sub(r'\x1b\[[0-9;]+[a-zA-Z]', '', data)

def getInfos(cme_file):
    r"""Read the given cme output file results and return a dictionnary with ips and a list of their open ports and infos.
        Args:
            cme_file:  the path to the .txt file generated by an cme.
        Returns:
        A tupe with 3 values:
            0. A List with dictionnaries inside.
                 Each dictionnary holds : "ip":str, "port":str, "hostname":str, "notes":str, "powned":bool
            1. a count of Powned found
            2. additional notes

    File example:

EMPTY :
\x1b[1m\x1b[34mSMB\x1b[0m          10.10.11.152    445    DC01             [1m[34m[*][0m Windows 10.0 Build 17763 x64 (name:DC01) (domain:timelapse.htb) (signing:True) (SMBv1:False)

POWNED EXEMPLE:
\x1b[1m\x1b[34mSMB\x1b[0m          10.10.10.254:445 HAGRID          \x1b[1m\x1b[34m[*]\x1b[0m Windows 6.3 Build 9600 (name:HAGRID) (domain:POUDLARD)
\x1b[1m\x1b[34mSMB\x1b[0m          10.10.10.254:445 HAGRID          \x1b[1m\x1b[32m[+]\x1b[0m POUDLARD\Administrateur:Algo_LAB_2012* \x1b[1m\x1b[33m(Pwn3d!)\x1b[0m
\x1b[1m\x1b[34m[*]\x1b[0m KTHXBYE!

NOT POWNED:
\x1b[1m\x1b[34mSMB\x1b[0m          10.10.10.11:445 DOBBY-PC        \x1b[1m\x1b[34m[*]\x1b[0m Windows 6.1 Build 0 (name:DOBBY-PC) (domain:POUDLARD)
\x1b[1m\x1b[34mSMB\x1b[0m          10.10.10.254:445 HAGRID          \x1b[1m\x1b[34m[*]\x1b[0m Windows 6.3 Build 9600 (name:HAGRID) (domain:POUDLARD)
\x1b[1m\x1b[34m[*]\x1b[0m KTHXBYE!

\x1b[1m\x1b[34mSMB\x1b[0m          10.10.11.152    445    DC01             [1m[34m[*][0m Windows 10.0 Build 17763 x64 (name:DC01) (domain:timelapse) (signing:True) (SMBv1:False)
\x1b[1m\x1b[34mSMB\x1b[0m         10.10.11.152    445    DC01             [1m[35m[-][0m timelapse\admin:admin STATUS_ACCESS_DENIED 

SMB         winterfell.north.sevenkingdoms.local 445    WINTERFELL       [-] north.sevenkingdoms.local\brandon.stark account vulnerable to asreproast attack 

"""
    result = {}
    retour = []
    regex_info = re.compile(r"(?:LDAP|SMB)\s+(\S+)\s+(\d+)\s+\S+\s+\[\*\]\s*([^\(]+)\(name:(.*)\) \(domain:(.*)\) \(signing:(True|False)\) \(SMBv1:(False|True)\)$", re.MULTILINE)
    regex_logon_failed = re.compile(
        r"(?:LDAP|SMB)\s+(\S+)\s+(\d+)\s+\S+\s+\[\-\]\s*([^\\]+)\\([^:\n]+):(.*?) [A-Z_]+$", re.MULTILINE)
    regex_success = re.compile(
        r"(?:LDAP|SMB)\s+(\S+)(?:\s+|:)(\d+)\s+(\S+)\s+\[\+\]\s*([^\\]+)\\([^:]+):(.*?)($|\(\S+\))$", re.MULTILINE)
    regex_module_lsassy = re.compile(r"^LSASSY\s+(\S+)\s+(\d+)\s+(\S+)\s+([^\\]+)\\(\S+)\s+(\S+)$")
    regex_module_secrets = re.compile(r"^(?:SMB|LDAP)\s+(\S+)\s+(\d+)\s+(\S+)\s+(?!\[.\])(\S.+)$")
    regex_module_asproast = re.compile(r"^(?:LDAP|SMB)\s+(\S+)\s+(\d+)\s+(\S+)\s+\[[-+]\] ([^\\]+)\\([^:]+) (account vulnerable to asreproast attack)\s*$")
    notes = ""
    countFound = 0
    countPwn = 0
    countSuccess = 0
    cmeFound = False
    lsassy = False
    mode = ""
    ntds = []
    secrets = []
    tags = []
    for line in cme_file:
        if isinstance(line, bytes):
            try:
                line = line.decode("utf-8", errors="ignore")
            except UnicodeDecodeError:
                result["success"] = False
                return result
                
        line=line.strip()
        line = remove_term_colors(line)
        # Search ip in file
        if line.startswith("SMB") or line.startswith("LDAP"):
            cmeFound = True
        if "Dumping LSA secrets" in line:
            mode = "lsa"
            continue
        elif "Dumped"  in line and "LSA secrets" in line:
            mode = ""
            continue
        elif "Dumping SAM hashes" in line:
            mode = "sam"
            continue
        elif "Added " in line and " SAM hashes" in line:
            mode = ""
            continue
        elif "Dumping the NTDS" in line:
            mode = "ntds"
            continue
        elif "Dumped " in line and "NTDS hashes" in line:
            mode = ""
            ntds = toAdd["ntds"]
            toAdd["type"] = "success"
            retour.append(toAdd)
            continue
        if mode == "":
            toAdd = {}
            if "LSASSY" in line and "Unable to dump lsass" not in line:
                lsassy = True
                res_lsassy = re.search(regex_module_lsassy, line)
                if res_lsassy is not None:
                    toAdd["type"] = "success"
                    toAdd["ip"] = res_lsassy.group(1)
                    toAdd["port"] = res_lsassy.group(2)
                    toAdd["machine_name"] = res_lsassy.group(3)
                    toAdd["domain"] = res_lsassy.group(4)
                    toAdd["username"] = success_infos.group(5)
                    password = success_infos.group(6)
                    if len(password) == 32:
                        try:
                            toAdd["hashNT"] = success_infos.group(6)
                        except:
                            toAdd["password"] = success_infos.group(6)
                    else:
                        toAdd["password"] = success_infos.group(6)
            else:
                res_infos = re.search(regex_info, line)
                res_asrep = re.search(regex_module_asproast, line)
                res_secrets = re.search(regex_module_secrets, line)
                if res_asrep is not None:
                    toAdd["type"] = "interesting"
                    toAdd["ip"] = res_asrep.group(1)
                    toAdd["port"] = res_asrep.group(2)
                    toAdd["machine_name"] = res_asrep.group(3)
                    toAdd["domain"] = res_asrep.group(4)
                    toAdd["username"] = res_asrep.group(5)
                    toAdd["reason"] = res_asrep.group(6).strip()
                    notes += f"ASREPROASTABLE USER FOUND: "+str(toAdd)
                
                if res_infos is not None:
                    toAdd["type"] = "info"
                    toAdd["ip"] = res_infos.group(1)
                    toAdd["port"] = res_infos.group(2)
                    toAdd["os"] = res_infos.group(3)
                    toAdd["machine_name"] = res_infos.group(4)
                    toAdd["domain"] = res_infos.group(5)
                    toAdd["signing"] = res_infos.group(6)
                    toAdd["smbv1"] = res_infos.group(7)
                    countFound += 1
                else:
                    success_infos = re.search(regex_success, line)
                    if success_infos is not None:
                        toAdd["type"] = "success"
                        toAdd["ip"] = success_infos.group(1)
                        toAdd["port"] = success_infos.group(2)
                        toAdd["machine_name"] = success_infos.group(3)
                        toAdd["domain"] = success_infos.group(4)
                        toAdd["username"] = success_infos.group(5)
                        toAdd["password"] = success_infos.group(6)
                        pwned = success_infos.group(7) != ""
                        toAdd["powned"] = pwned
                        if pwned:
                            countPwn += 1
                        else:
                            countSuccess += 1
                    elif res_secrets is not None:
                        toAdd["type"] = "success"
                        toAdd["ip"] = res_secrets.group(1)
                        toAdd["port"] = res_secrets.group(2)
                        toAdd["machine_name"] = res_secrets.group(3)
                        secret = res_secrets.group(4)
                        if secret and secret != "":
                            secrets.append(line)
                            if secret.startswith("$krb5asrep$"):
                                parts = secret.split("$")
                                try:
                                    data = parts[3]
                                    data_parts = data.split(":")[0].split("@")
                                    toAdd["username"] = "@".join(data_parts[0:-1])
                                    toAdd["domain"] = data_parts[-1]
                                    toAdd["secrets"] = [secret]
                                except IndexError as e:
                                    toAdd["secrets"] += [secret]
                    else:
                        failure_infos = re.search(regex_logon_failed, line)
                        if failure_infos is not None:
                            toAdd["type"] = "failure"
                            toAdd["ip"] = failure_infos.group(1)
                            toAdd["port"] = failure_infos.group(2)
                            toAdd["machine_name"] = failure_infos.group(3)
                            toAdd["domain"] = failure_infos.group(4)
                            toAdd["username"] = failure_infos.group(5)
                            toAdd["reason"] = failure_infos.group(6).strip()
                        
            if toAdd.keys():
                retour.append(toAdd)
        
        if mode == "lsa" or mode == "sam":
            module_infos = re.search(regex_module_secrets, line)
            if module_infos is None:
                continue
            if toAdd.get("ip", None) is not None:
                if "toAdd" in locals():
                    toAdd["secrets"] = toAdd.get("secrets", []) + [module_infos.group(4)]
            secrets.append(line)
        elif mode == "ntds":
            module_infos = re.search(regex_module_secrets, line)
            if module_infos is None:
                continue
            if "toAdd" in locals():
                toAdd["ip"] = module_infos.group(1)
                toAdd["port"] = module_infos.group(2)
                toAdd["machine_name"] = module_infos.group(3)
                toAdd["ntds"] = toAdd.get("ntds", []) + [module_infos.group(4)]
                
    if not cmeFound:
        result["success"] = False
        return result
    if lsassy:
        notes = f"CME LSASSY Success"
    notes = f"Pwn3d count : {countPwn}\nConnection success count : {countSuccess}\nHost found : {countFound}\nNTDS dump : {len(ntds)}\nSecrets found : {len(secrets)}\n"+ ("\n".join(secrets)) + notes
    result["retour"] = retour
    result["notes"] = notes
    result["countPwn"] = countPwn
    result["countSuccess"] = countSuccess
    result["success"] = True
    result["secrets"] = secrets
    result["lsassy"] = lsassy
    result["ntds"] = ntds
    result["tags"] = tags
    return result


def editScopeIPs(pentest, hostsInfos):
    """
    Add all the ips and theirs ports found after parsing the file to the scope object in database.
    Args:
        hostsInfos: the dictionnary with ips as keys and a list of dictionnary containing ports informations as value.
    """
    # Check if any ip has been found.
    targets = {}
    if hostsInfos is not None:
        for infos in hostsInfos:
            infosToAdd = {}
            if infos["type"] == "info":
                thisOS = infos.get("os", "")
                if thisOS != "":
                    infosToAdd["os"] = thisOS
                machine_name = infos.get("machine_name", "")
                if machine_name != "":
                    infosToAdd["machine_name"] = machine_name
                SMBv1 = infos.get("smbv1", "")
                if SMBv1 != "":
                    infosToAdd["smbv1"] = SMBv1
                signing = infos.get("signing", "")
                if signing != "":
                    infosToAdd["signing"] = signing
                domain = infos.get("domain", "")
                if domain != "":
                    infosToAdd["domain"] = domain
            elif infos["type"] == "failure":
                if infos["reason"] in ["KDC_ERR_PREAUTH_FAILED", "KDC_ERR_CLIENT_REVOKED"]:
                    user_model = User(pentest).initialize(pentest, None, infos.get("domain", ""), infos.get("username", ""), None)
                    infosToAdd["users"] = infosToAdd.get("users", []) + [user_model]
            elif infos["type"] == "interesting":
                if "asreproast" in infos["reason"]:
                    user_info = infos
                    user_info["asreproastable"] = True
                    user_model = User(pentest).initialize(pentest, None, infos.get("domain", ""), infos.get("username", ""), infos=user_info)
                    infosToAdd["users"] = infosToAdd.get("users", []) + [user_model]
                    
            elif infos["type"] == "success":
                powned = infos.get("powned", False)
                user_info = infos
                secrets = infos.get("secrets", [])
                if secrets:
                    infosToAdd["secrets"] = infosToAdd.get("secrets", []) + secrets
                    user_info["secrets"] = secrets
                ntds = infos.get("ntds", [])
                if ntds:
                    del infos["ntds"]
                    infosToAdd["ntds"] = ntds
                    regex_ntds = re.compile(r"^\s*(\S+):\d+:([a-f0-9]+):([a-f0-9]+):::\s*$")
                    for line in ntds:
                        matched = re.search(regex_ntds, line)
                        if matched:
                            username = matched.group(1)
                            this_info = {}
                            hashLM = matched.group(2)
                            hashNT = matched.group(3)
                            if hashLM != "aad3b435b51404eeaad3b435b51404ee":
                                this_info["hashLM"] = hashLM
                            this_info["hashNT"] = hashNT
                            user_model = User(pentest).initialize(pentest, None, infos.get("domain", ""), username, "", infos=this_info)
                            infosToAdd["users"] = infosToAdd.get("users", []) + [user_model]
                hashNT = infos.get("hashNT", "")
                if hashNT != "":
                    user_info["hashNT"] = hashNT
                user_model = User(pentest).initialize(pentest, None, infos.get("domain", ""), infos.get("username", ""), infos.get("password"), infos=user_info)
                infosToAdd["users"] = infosToAdd.get("users", []) + [user_model]
                if powned:
                    infosToAdd["powned"] = powned
                    infosToAdd["admins"] = infosToAdd.get("admins", []) + [user_model]
                

            ip_m = ServerIp(pentest).initialize(str(infos["ip"]), infos={"plugin":CME.get_name()})
            insert_ret = ip_m.addInDb()
            if not insert_ret["res"]:
                ip_m = ServerIp.fetchObject(pentest, {"_id": insert_ret["iid"]})
            ip_m.notes = "machine_name:" + \
                infos["machine_name"] + "\n"+infos.get("os", "")
            if infos["type"] == "success":
                if infos.get("powned", False):
                    ip_m.addTag(Tag("pwned", "red", "high", notes=str(infos)))
            host = str(infos["ip"])
            port = str(infos["port"])
            proto = "tcp"
            service = "netbios-ssn"
            port_m = ServerPort(pentest).initialize(host, port, proto, service, infos={"plugin":CME.get_name()})
            insert_ret = port_m.addInDb()
            port_m = ServerPort.fetchObject(pentest, {"_id": insert_ret["iid"]})

            if infos.get("powned", False):
                port_m.addTag(Tag("pwned", "red", "high", notes=str(infos)), True)
            computer_m = Computer.fetchObject(pentest, {"ip":port_m.ip})
            if computer_m is not None: 
                users = infosToAdd.get("users", [])
                for user in users:
                    if isinstance(user, User):
                        user_iid = computer_m.add_user(computer_m.domain, user.username, user.password, user.infos)
                        user_m = User.fetchObject(pentest, {"_id":ObjectId(user_iid)})
                        if user.infos.get("asreproastable", False):
                            user_m.addTag(Tag("asreproastable", color="orange", level="high", notes=f"{user.domain}\\{user.username} is asreproastable"), True)
                        if user.infos.get("secrets", []):
                            user_m.addTag(Tag("user-secrets-found", color="red", level="high", notes=f"{user.domain}\\{user.username} has secrets : {infos.get('secrets')}"), True)
                        if user.infos.get("hashLM", "") != "":
                            user_m.addTag(Tag("hashLM-found", color="red", level="high", notes=f"{user.domain}\\{user.username} has hashLM : {user.infos.get('hashLM')}"), True)
                        if user.infos.get("hashNT", "") != "":
                            user_m.addTag(Tag("hashNT-found", color="red", level="high", notes=f"{user.domain}\\{user.username} has hashNT : {user.infos.get('hashNT')}"), True)
                    else:
                        computer_m.add_user(user[0], user[1], user[2])
                admins = infosToAdd.get("admins", [])
                for user in admins:
                    if isinstance(user, User):
                        user_iid = computer_m.add_admin(user.domain, user.username, user.password) 
                    else:
                        computer_m.add_admin(user[0], user[1], user[2])
                computer_m.name = infos["machine_name"]
                computer_m.domain = infos.get("domain")
                d = computer_m.getData()
                
                comp_info = d["infos"]
                comp_info["plugin"] = CME.get_name()

                comp_info.update(infosToAdd)
                computer_m = Computer(pentest, d)
                computer_m.update()
                if d["infos"].get("signing", True) == False:
                    computer_m.addTag(Tag("signing-disabled", "orange", "medium", f"Signing is disabled on {computer_m.name}"), True)
                if d["infos"].get("smbv1", True) == False:
                    computer_m.addTag(Tag("smbv1-enabled", "orange", "medium", f"SMBv1 is enabled on {computer_m.name}"), True)
            if "users" in infosToAdd:
                del infosToAdd["users"]
            if "admins" in infosToAdd:
                del infosToAdd["admins"]
            port_m.updateInfos(infosToAdd)
            targets[str(insert_ret["iid"])] = {
                    "ip": host, "port": port, "proto": proto}
    return targets

class CME(Plugin):
    """Inherits Plugin
    A plugin to parse a crackmapexec scan"""
    default_bin_names = ["cme", "crackmapexec"]
    def getFileOutputArg(self):
        """Returns the command line paramater giving the output file
        Returns:
            string
        """
        return " | tee "

    def getFileOutputExt(self):
        """Returns the expected file extension for this command result file
        Returns:
            string
        """
        return ".log.txt"

    def getFileOutputPath(self, commandExecuted):
        """Returns the output file path given in the executed command using getFileOutputArg
        Args:
            commandExecuted: the command that was executed with an output file inside.
        Returns:
            string: the path to file created
        """
        return commandExecuted.split(self.getFileOutputArg())[-1].strip().split(" ")[0]

    def getTags(self):
        """Returns a list of tags that can be added by this plugin
        Returns:
            list of strings
        """
        return {"pwned-cme" : Tag("pwned-cme", "red", "high"), 
                "info-cme-connection-success": Tag("info-cme-connection-success", "green", "info"),
                "todo-cme-secrets-found": Tag("todo-cme-secrets-found", "red", "todo"),
                "todo-lsassy-success": Tag("todo-lsassy-success", "red", "todo"),
                "user-secrets-found": Tag("user-secrets-found", "red", "high"),
                "asreproastable": Tag("asreproastable", "orange", "high"),
                "pwned": Tag("pwned", "red", "high"),
                "signing-disabled": Tag("signing-disabled", "orange", "medium"),
                "smbv1-enabled" : Tag("smbv1-enabled", "orange", "medium"),
                "pwned-ntds": Tag("pwned-ntds", "black", "critical"),
                "hashLM-found": Tag("hashLM-found", "red", "high")}


    def Parse(self, pentest, file_opened, **_kwargs):
        """
        Parse a opened file to extract information
       
        Args:
            file_opened: the open file
            _kwargs: not used
        Returns:
            a tuple with 4 values (All set to None if Parsing wrong file): 
                0. notes: notes to be inserted in tool giving direct info to pentester
                1. tags: a list of tags to be added to tool 
                2. lvl: the level of the command executed to assign to given targets
                3. targets: a list of composed keys allowing retrieve/insert from/into database targerted objects.
        """
        tags = []
        result = getInfos(file_opened)
        if result.get("success", False) == False:
            return None, None, None, None
        hostsInfos = result.get("retour", [])
        if result.get("countPwn") is not None:
            count = int(result.get("countPwn"))
            if count > 0:
                tags += [Tag(self.getTags()["pwned-cme"], notes=f"{count} hosts pwned")]
        if result.get("countSuccess") is not None:
            count = int(result.get("countSuccess"))
            if count > 0:
                tags += [Tag(self.getTags()["info-cme-connection-success"], notes=f"{count} hosts connected")]
            if len(result.get("secrets",[])) > 0:
                tags += [Tag(self.getTags()["todo-cme-secrets-found"], notes=f"{len(result.get('secrets',[]))} secrets found")]
            if result.get("lsassy"):
                tags += [Tag(self.getTags()["todo-lsassy-success"], notes=f"lsassy success")]
            if len(result.get("ntds", [])) > 0:
                tags += [Tag(self.getTags()["pwned-ntds"], notes=f"{len(result.get('ntds',[]))} ntds found")]
        if hostsInfos is None:
            return None, None, None, None
        targets = editScopeIPs(pentest, hostsInfos)
        return result.get("notes", ""), tags, "ports", targets
