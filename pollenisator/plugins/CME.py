"""A plugin to parse a CrackMapExex scan"""

import re
from pollenisator.server.ServerModels.Ip import ServerIp
from pollenisator.server.ServerModels.Port import ServerPort
from pollenisator.server.modules.ActiveDirectory.computers import Computer

from pollenisator.plugins.plugin import Plugin


def getInfos(cme_file):
    r"""Read the given cme output file results and return a dictionnary with ips and a list of their open ports and infos.
        Args:
            cme_file:  the path to the .txt file generated by an cme.
        Returns:
        A tupe with 3 values:
            0. A List with dictionnaries inside.
                 Each dictionnary holds : "ip":str, "port":str, "hostname":str, "notes":str, "powned":bool
            1. a count of Powned found
            2. additional notes

    File example:

EMPTY :
[1m[34mSMB[0m         10.10.11.152    445    DC01             [1m[34m[*][0m Windows 10.0 Build 17763 x64 (name:DC01) (domain:timelapse.htb) (signing:True) (SMBv1:False)

POWNED EXEMPLE:
\x1b[1m\x1b[34mCME\x1b[0m          10.10.10.254:445 HAGRID          \x1b[1m\x1b[34m[*]\x1b[0m Windows 6.3 Build 9600 (name:HAGRID) (domain:POUDLARD)
\x1b[1m\x1b[34mCME\x1b[0m          10.10.10.254:445 HAGRID          \x1b[1m\x1b[32m[+]\x1b[0m POUDLARD\Administrateur:Algo_LAB_2012* \x1b[1m\x1b[33m(Pwn3d!)\x1b[0m
\x1b[1m\x1b[34m[*]\x1b[0m KTHXBYE!

NOT POWNED:
\x1b[1m\x1b[34mCME\x1b[0m          10.10.10.11:445 DOBBY-PC        \x1b[1m\x1b[34m[*]\x1b[0m Windows 6.1 Build 0 (name:DOBBY-PC) (domain:POUDLARD)
\x1b[1m\x1b[34mCME\x1b[0m          10.10.10.254:445 HAGRID          \x1b[1m\x1b[34m[*]\x1b[0m Windows 6.3 Build 9600 (name:HAGRID) (domain:POUDLARD)
\x1b[1m\x1b[34m[*]\x1b[0m KTHXBYE!

[1m[34mSMB[0m         10.10.11.152    445    DC01             [1m[34m[*][0m Windows 10.0 Build 17763 x64 (name:DC01) (domain:timelapse) (signing:True) (SMBv1:False)
[1m[34mSMB[0m         10.10.11.152    445    DC01             [1m[35m[-][0m timelapse\admin:admin STATUS_ACCESS_DENIED 

CONNECTED
^[[1m^[[34mCME^[[0m          10.0.0.86:445 ALGOSECURE-VM   ^[[1m^[[34m[*]^[[0m Windows 10.0 Build 18362 (name:ALGOSECURE-VM) (domain:ALGOSECURE-VM)
^[[1m^[[34mCME^[[0m          10.0.0.86:445 ALGOSECURE-VM   ^[[1m^[[32m[+]^[[0m ALGOSECURE-VM\algosecure:Alg123!*
"""
    retour = []
    regex_info = re.compile(r"^\S+SMB\S+\s+(\S+)\s+(\d+)\s+\S+\s+\S+\[\*\]\S+\s+([^\(]+)\(name:(.+)\) \(domain:(.+)\) \(signing:(True|False)\) \(SMBv1:(False|True)\)$", re.MULTILINE)
    regex_logon_failed = re.compile(
        r"^\S+SMB\S+\s+(\S+)\s+(\d+)\s+(\S+)\s+\S+\[\-\]\S+ ([^\\]+)\\([^:]+):(.*?) STATUS_LOGON_FAILURE\s*$", re.MULTILINE)
    regex_success = re.compile(
        r"^\S+SMB\S+\s+(\S+)\s+(\d+)\s+(\S+)\s+\S+\[\+\]\S+ ([^\\]+)\\([^:]+):(.*?)(?= \x1b)(.+)$", re.MULTILINE)
    regex_module_lsassy = re.compile(r"^\S+LSASSY\S+\s+(\S+)\s+(\d+)\s+(\S+)\s+\S+\[33m([^\\]+)\\(\S+)\s+(\S+)(?=\x1b).+$")
    regex_module_ntds = re.compile(r"^\S+SMB\S+\s+(\S+)\s+(\d+)\s+(\S+)\s+\S+\[33m(.+)\x1b\S*$")
    notes = ""
    countFound = 0
    countPwn = 0
    countSuccess = 0
    cmeFound = False
    lsassy = False
    mode = ""
    secrets = []
    for line in cme_file:
        if isinstance(line, bytes):
            line = line.decode("utf-8")
        line=line.strip()
        # Search ip in file
        if "\x1b[1m\x1b[34mSMB\x1b[0m" in line:
            cmeFound = True
        if "Dumping LSA secrets" in line:
            mode = "lsa"
            continue
        elif "Dumped"  in line and "LSA secrets" in line:
            mode = ""
            continue
        elif "Dumping SAM hashes" in line:
            mode = "sam"
            continue
        elif "Added " in line and " SAM hashes" in line:
            mode = ""
            continue
        elif "Dumping the NTDS" in line:
            mode = "ntds"
            continue
        elif "Dumped " in line and "NTDS hashes" in line:
            mode = ""
            continue
        if mode == "":
            toAdd = {}
            if "LSASSY" in line and "Unable to dump lsass" not in line:
                lsassy = True
                res_lsassy = re.search(regex_module_lsassy, line)
                if res_lsassy is not None:
                    toAdd["type"] = "success"
                    toAdd["ip"] = res_lsassy.group(1)
                    toAdd["port"] = res_lsassy.group(2)
                    toAdd["machine_name"] = res_lsassy.group(3)
                    toAdd["domain"] = res_lsassy.group(4)
                    toAdd["username"] = success_infos.group(5)
                    password = success_infos.group(6)
                    if len(password) == 32:
                        try:
                            toAdd["hashNT"] = success_infos.group(6)
                        except:
                            toAdd["password"] = success_infos.group(6)
                    else:
                        toAdd["password"] = success_infos.group(6)
            else:
                res_infos = re.search(regex_info, line)
                if res_infos is not None:
                    toAdd["type"] = "info"
                    toAdd["ip"] = res_infos.group(1)
                    toAdd["port"] = res_infos.group(2)
                    toAdd["os"] = res_infos.group(3)
                    toAdd["machine_name"] = res_infos.group(4)
                    toAdd["domain"] = res_infos.group(5)
                    toAdd["signing"] = res_infos.group(6)
                    toAdd["smbv1"] = res_infos.group(7)
                    countFound += 1
                else:
                    success_infos = re.search(regex_success, line)
                    if success_infos is not None:
                        toAdd["type"] = "success"
                        toAdd["ip"] = success_infos.group(1)
                        toAdd["port"] = success_infos.group(2)
                        toAdd["machine_name"] = success_infos.group(3)
                        toAdd["domain"] = success_infos.group(4)
                        toAdd["username"] = success_infos.group(5)
                        toAdd["password"] = success_infos.group(6)
                        pwned = "(Pwn3d!)" in success_infos.group(7)
                        toAdd["powned"] = pwned
                        if pwned:
                            countPwn += 1
                        else:
                            countSuccess += 1
                    else:
                        failure_infos = re.search(regex_logon_failed, line)
                        if failure_infos is not None:
                            toAdd["type"] = "failure"
                            toAdd["ip"] = failure_infos.group(1)
                            toAdd["port"] = failure_infos.group(2)
                            toAdd["machine_name"] = failure_infos.group(3)
                            toAdd["domain"] = failure_infos.group(4)
                            toAdd["username"] = failure_infos.group(5)
                            toAdd["password"] = failure_infos.group(6)
                        
            if toAdd.keys():
                retour.append(toAdd)
        
        if mode == "lsa" or mode == "sam":
            module_infos = re.search(regex_module_ntds, line)
            if module_infos is None:
                continue
            if toAdd.get("ip", None) is not None:
                if "toAdd" in locals():
                    toAdd["secrets"] = toAdd.get("secrets", []) + [module_infos.group(4)]
            secrets.append(line)
        elif mode == "ntds":
            module_infos = re.search(regex_module_ntds, line)
            if module_infos is None:
                continue
            if "toAdd" in locals():
                toAdd["ntds"] = toAdd.get("ntds", []) + [module_infos.group(4)]
    if not cmeFound:
        return None, None, None, None, None, None
    if lsassy:
        notes = f"CME LSASSY Success"
    notes = f"Pwn3d count : {countPwn}\nConnection success count : {countSuccess}\nHost found : {countFound}\nSecrets found : {len(secrets)}\n"+ ("\n".join(secrets)) + notes
    return retour, countPwn, countSuccess, notes, secrets, lsassy


def editScopeIPs(pentest, hostsInfos):
    """
    Add all the ips and theirs ports found after parsing the file to the scope object in database.
    Args:
        hostsInfos: the dictionnary with ips as keys and a list of dictionnary containing ports informations as value.
    """
    # Check if any ip has been found.
    targets = {}
    if hostsInfos is not None:
        for infos in hostsInfos:
            infosToAdd = {}
            if infos["type"] == "info":
                thisOS = infos.get("os", "")
                if thisOS != "":
                    infosToAdd["os"] = thisOS
                machine_name = infos.get("machine_name", "")
                if machine_name != "":
                    infosToAdd["machine_name"] = machine_name
                SMBv1 = infos.get("smbv1", "")
                if SMBv1 != "":
                    infosToAdd["smbv1"] = SMBv1
                signing = infos.get("signing", "")
                if signing != "":
                    infosToAdd["signing"] = signing
                domain = infos.get("domain", "")
                if domain != "":
                    infosToAdd["domain"] = domain
            elif infos["type"] == "success" or infos["type"] == "failure":
                powned = infos.get("powned", False)
                creds = (infos.get("domain", ""), infos.get("username", ""), infos.get("password", infos.get("hashNT", "")))
                infosToAdd["users"] = infosToAdd.get("users", []) + [creds]
                if powned:
                    infosToAdd["powned"] = powned
                    infosToAdd["admins"] = infosToAdd.get("admins", []) + [creds]
                secrets = infos.get("secrets", [])
                if secrets:
                    infosToAdd["secrets"] = infosToAdd.get("secrets", []) + secrets

            ip_m = ServerIp().initialize(str(infos["ip"]))
            insert_ret = ip_m.addInDb()
            if not insert_ret["res"]:
                ip_m = ServerIp.fetchObject(pentest, {"_id": insert_ret["iid"]})
            ip_m.notes = "machine_name:" + \
                infos["machine_name"] + "\n"+infos.get("os", "")
            if infos["type"] == "success":
                if infos.get("powned", False):
                    ip_m.addTag("pwned")
            host = str(infos["ip"])
            port = str(infos["port"])
            proto = "tcp"
            service = "netbios-ssn"
            port_m = ServerPort().initialize(host, port, proto, service)
            insert_ret = port_m.addInDb()
            port_m = ServerPort.fetchObject(pentest, {"_id": insert_ret["iid"]})

            if infos.get("powned", False):
                port_m.addTag("pwned")
            computer_m = Computer.fetchObject(pentest, {"ip":port_m.ip})
            if computer_m is not None: 
                creds = infosToAdd.get("users", [])
                for cred in creds:
                    computer_m.add_user(cred[0], cred[1], cred[2])
                creds = infosToAdd.get("admins", [])
                for cred in creds:
                    computer_m.add_admin(cred[0], cred[1], cred[2])
                computer_m.name = infos["machine_name"]
                computer_m.domain = infos.get("domain")
                d = computer_m.getData()
                comp_info = d["infos"]
                comp_info.update(infosToAdd)
                computer_m = Computer(pentest, d)
                computer_m.update()
            if "users" in infosToAdd:
                del infosToAdd["users"]
            if "admins" in infosToAdd:
                del infosToAdd["admins"]
            port_m.updateInfos(infosToAdd)
            targets[str(insert_ret["iid"])] = {
                    "ip": host, "port": port, "proto": proto}
    return targets

class CME(Plugin):
    """Inherits Plugin
    A plugin to parse a crackmapexec scan"""

    def getFileOutputArg(self):
        """Returns the command line paramater giving the output file
        Returns:
            string
        """
        return " | tee "

    def getFileOutputExt(self):
        """Returns the expected file extension for this command result file
        Returns:
            string
        """
        return ".log.txt"

    def getFileOutputPath(self, commandExecuted):
        """Returns the output file path given in the executed command using getFileOutputArg
        Args:
            commandExecuted: the command that was executed with an output file inside.
        Returns:
            string: the path to file created
        """
        return commandExecuted.split(self.getFileOutputArg())[-1].strip().split(" ")[0]


    def Parse(self, pentest, file_opened, **_kwargs):
        """
        Parse a opened file to extract information
       
        Args:
            file_opened: the open file
            _kwargs: not used
        Returns:
            a tuple with 4 values (All set to None if Parsing wrong file): 
                0. notes: notes to be inserted in tool giving direct info to pentester
                1. tags: a list of tags to be added to tool 
                2. lvl: the level of the command executed to assign to given targets
                3. targets: a list of composed keys allowing retrieve/insert from/into database targerted objects.
        """
        notes = ""
        tags = []
        hostsInfos, countPwnd,  countSuccess, notes, secrets, lsassy = getInfos(file_opened)
        if countPwnd is not None:
            if int(countPwnd) > 0:
                tags = ["cme-pwned"]
        if countSuccess is not None:
            if int(countSuccess) > 0:
                tags += ["cme-connection-success"]
            if len(secrets) > 0:
                tags += ["cme-secrets-dump"]
            if lsassy:
                tags += ["lsassy-success"]
        if hostsInfos is None:
            return None, None, None, None
        targets = editScopeIPs(pentest, hostsInfos)
        return notes, tags, "ports", targets
