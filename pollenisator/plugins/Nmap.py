"""A plugin to parse nmap scan"""
import re
from pollenisator.core.components.mongo import DBClient
from pollenisator.core.components.tag import Tag
from pollenisator.server.servermodels.ip import ServerIp
from pollenisator.server.servermodels.port import ServerPort
from pollenisator.plugins.plugin import Plugin
import shlex
import time
from pollenisator.core.components.logger_config import logger

def getIpPortsNmap(pentest, nmapFile, keep_only_open=True):
    """
    Read the given nmap .nmap file results and return a dictionnary with ips and a list of their open ports.
        Args:
            nmapFile:  the path to the .nmap file generated by an nmap scan

        Returns:
            notes about inseted ip and ports
    """
    dbclient = DBClient.getInstance()
    notes = ""
    countOpen = 0
    ports_to_add = []
    ips_to_add = []
    first_line = nmapFile.readline().decode("utf-8", errors="ignore").strip()
    nmapFile.seek(0, 2) # Move the file cursor to the end
    # Get the file size
    file_size = nmapFile.tell()
    nmapFile.seek(max(file_size - 1024, 0))  # You can adjust the buffer size as needed
    # Read the last line
    last_line = nmapFile.readlines()[-1].decode("utf-8", errors="ignore").strip()
    if file_size <= 200:
        # print("Not enough lines to be nmap")
        return None
    if not first_line.startswith("# Nmap"):
        # print("Not starting with # Nmap")
        return None
    if "scan initiated" not in first_line:
        # print("Not scan initiated on first line")
        return None
    if "# Nmap done at" not in last_line:
        # print("Not # Nmap done at at the end : "+str(lines[-1]))
        return None
    nmapFile.seek(0)
    ipCIDR_m = None
    ipDom_m = None

    regex_scan_report = re.compile(r"^Nmap scan report for (\S+)(?: \(((?:[0-9]{1,3}\.){3}[0-9]{1,3})\))?$")
    regex_port = re.compile(r"^(\d+)\/(\S+)\s+open\s+(\S+)(?: +(.+))?$")
    first_port = False
    for line in nmapFile:
        # Search ip in file
        # match an ip
        if isinstance(line, bytes):
            try:
                line = line.decode("utf-8", errors="ignore")
            except UnicodeDecodeError:
                continue
        ip = re.search(
            regex_scan_report, line)
        if ip is not None:  # regex match
            # IF THE LIST IS BIG, WE SHOULD FLUSH IT
            if len(ips_to_add) >= 10000:
                bulk_insertions(pentest, ips_to_add, ports_to_add)
                ips_to_add = []
                ports_to_add = []
            lastIp = [ip.group(1), ip.group(
                2) if ip.group(2) is not None else ""]
            notes_ip = "ip:" + \
                str(lastIp[1]) if lastIp[1] != "" and lastIp[1] is not None else ""
            ipCIDR_m = ServerIp(pentest, {"in_scopes":[]}).initialize(str(lastIp[0]), notes=notes_ip, in_scopes=[], infos={"plugin":Nmap.get_name()})
            if not keep_only_open:#add directly
                ips_to_add.append(ipCIDR_m)
            if lastIp[1].strip() != "" and lastIp[1] is not None:
                ipDom_m = ServerIp(pentest, {"in_scopes":[]}).initialize(
                    str(lastIp[1]), notes="domain:"+str(lastIp[0]), in_scopes=[], infos={"plugin":Nmap.get_name()})
                if not keep_only_open:#add directly
                    ips_to_add.append(ipDom_m)
            else:
                ipDom_m = None
            first_port = True
        if " open " in line:
            if ipCIDR_m is None:  # Probably a gnmap
                return None
            #notes += line+"\n"
            # regex to find open ports in gnmap file
            port_search = re.search(
                regex_port, line)
            if port_search is not None:
                port_number = str(port_search.group(1))
                proto = str(port_search.group(2))
                service = "unknown" if str(port_search.group(
                    3)) == "" else str(port_search.group(3))
                product = str(port_search.group(4))
                # a port unique key is its protocole/number.
                countOpen += 1
                validIps = []
                if ipCIDR_m is not None:
                    if keep_only_open and first_port:
                        ips_to_add.append(ipCIDR_m)
                    validIps.append(ipCIDR_m.ip)
                    if ipDom_m is not None:
                        ipDom_m.infos["hostname"] = list(set(list( ipDom_m.infos.get("hostname", []))+[str(ipCIDR_m.ip)]))
                        validIps.append(ipDom_m.ip)
                        ips_to_add.append(ipDom_m)
                    first_port = False
                for ipFound in validIps:
                    if ip == "":
                        continue
                    port_o = ServerPort(pentest).initialize(ipFound, port_number, proto, service, product, infos={"plugin":Nmap.get_name()})
                    ports_to_add.append(port_o)
    bulk_insertions(pentest, ips_to_add, ports_to_add)
    notes = str(countOpen)+" open ports found\n"+notes
    return notes

def bulk_insertions(pentest, ips_to_add, ports_to_add):
    """Bulk insertions of ips and ports
    """
    start = time.time()
    ServerIp.bulk_insert(pentest, ips_to_add, look_scopes=True)
    logger.info("Insertion of ips took "+str(time.time()-start)+" seconds")
    start = time.time()
    results = ServerPort.bulk_insert(pentest, ports_to_add)
    logger.info("Insertion of ports took "+str(time.time()-start)+" seconds")
    
class Nmap(Plugin):
    default_bin_names = ["nmap"]
    def getFileOutputArg(self):
        """Returns the command line paramater giving the output file
        Returns:
            string
        """
        return " -oN "

    def getFileOutputExt(self):
        """Returns the expected file extension for this command result file
        NMAP EXPECT .nmap but -oN will append it
        Returns:
            string
        """
        return ".nmap"
        

    def getFileOutputPath(self, commandExecuted):
        """Returns the output file path given in the executed command using getFileOutputArg
        Args:
            commandExecuted: the command that was executed with an output file inside.
        Returns:
            string: the path to file created
        """
        return (commandExecuted.split(self.getFileOutputArg())[-1].strip().split(" ")[0])
    
    def changeCommand(self, command, outputDir, toolname):
        """
        Summary: Complete the given command with the tool output file option and filename absolute path.
        Args:
            * command : the command line to complete
            * outputDir : the directory where the output file must be generated
            * toolname : the tool name (to be included in the output file name)
        Return:
            The command completed with the tool output file option and filename absolute path.
        """
        #Â default is append at the end
        if self.getFileOutputArg() not in command:
            parts = shlex.split(command) 
            parts.insert(1, self.getFileOutputArg()+outputDir+toolname)
            return " ".join(parts)
        return command

    def getTags(self):
        """Returns a list of tags that can be added by this plugin
        Returns:
            list of strings
        """
        return {"info-nmap": Tag("info-nmap", level="info")}

    def Parse(self, pentest, file_opened, **kwargs):
        """
        Parse a opened file to extract information
        Args:
            file_opened: the open file
            kwargs: 
                "tool" -> ToolModel if file is associated with a tool
                "cmdline" -> if cmdline was given , the command line runned to get this
        Returns:
            a tuple with 4 values (All set to None if Parsing wrong file): 
                0. notes: notes to be inserted in tool giving direct info to pentester
                1. tags: a list of tags to be added to tool 
                2. lvl: the level of the command executed to assign to given targets
                3. targets: a list of composed keys allowing retrieve/insert from/into database targerted objects.
        """
        
        if kwargs.get("ext", "").lower() != self.getFileOutputExt():
            return None, None, None, None
        tags = [self.getTags()["info-nmap"]]
        cmdline = kwargs.get("cmdline", None)
        tool_m = kwargs.get("tool", None)
        keep_only_open = True
        if cmdline is None and tool_m is not None:
            cmdline = tool_m.infos.get("cmdline", None)
        if cmdline is not None:
            if " -sP " in cmdline:
                keep_only_open = False
        notes = getIpPortsNmap(pentest, file_opened, keep_only_open)
        if notes is None:
            return None, None, None, None
        return notes, tags, "scope", {}
