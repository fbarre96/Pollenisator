# coding: utf-8

from __future__ import absolute_import
from bson import ObjectId
from pymongo import UpdateOne
from pollenisator.core.components.mongo import DBClient
from pollenisator.core.components.logger_config import logger
from pollenisator.server.servermodels.element import ServerElement
from pollenisator.server.servermodels.command import ServerCommand
from pollenisator.server.servermodels.tool import ServerTool
from pollenisator.server.modules.cheatsheet.cheatsheet import CheckItem
from pollenisator.server.modules.activedirectory.computer_infos import ComputerInfos
from pollenisator.server.modules.activedirectory.users import User
from pollenisator.server.modules.cheatsheet.checkinstance import CheckInstance
from pollenisator.server.permission import permission

class Computer(ServerElement):
    coll_name = "computers"
    command_variables = ["domain"]
    
    """NOTE: This class is was generated by OpenAPI Generator (https://openapi-generator.tech).
    """

    def __init__(self, pentest, valuesFromDb=None):
        if valuesFromDb is None:
            valuesFromDb = {}
        self.initialize(pentest, valuesFromDb.get("_id"),  valuesFromDb.get("name"), valuesFromDb.get("ip"), \
             valuesFromDb.get("domain"),  valuesFromDb.get("admins"),  valuesFromDb.get("users"), valuesFromDb.get("infos"))

    def initialize(self, pentest=None, _id=None, name=None, ip=None, domain=None, admins=None, users=None, infos=None):  # noqa: E501
        """Computer - a model defined in OpenAPI
        :param pentest: current pentest 
        :type pentest: str
        :param _id: iid of the object
        :type _id: str
        :param name: The name of this Computer.  # noqa: E501
        :type name: str
        :param ip: The ip of this Computer.  # noqa: E501
        :type ip: str
        :param domain: The domain of this Computer.  # noqa: E501
        :type domain: str
        :param admins: The admins of this Computer.  # noqa: E501
        :type admins: List[str]
        :param users: The users of this Computer.  # noqa: E501
        :type users: List[str]
        :param infos: The infos of this Computer.  # noqa: E501
        :type infos: ComputerInfos
        """

        self._id = _id
        self.name = name
        self.ip = ip
        self.domain = domain
        self.admins = admins
        self.users = users
        self._infos = ComputerInfos(infos)
        dbclient = DBClient.getInstance()
        if pentest != "":
            self.pentest = pentest
        elif dbclient.current_pentest != "":
            self.pentest = dbclient.current_pentest
        else:
            raise ValueError("An empty pentest name was given and the database is not set in mongo instance.")
    
    def __str__(self):
        """
        Get a string representation of a defect.

        Returns:
            Returns the defect +title.
        """
        return str(self.domain)+"\\"+str(self.name) + " ("+str(self.ip)+")"
    
    @classmethod
    def getSearchableTextAttribute(cls):
        return ["domain", "name", "ip"]

    def getData(self):
        return {"_id": self._id, "name":self.name, "ip":self.ip, "domain":self.domain,
            "admins":self.admins, "users": self.users, "infos":self.infos.getData()}
    
    

    @classmethod
    def fetchObjects(cls, pentest, pipeline):
        """Fetch many commands from database and return a Cursor to iterate over model objects
        Args:
            pipeline: a Mongo search pipeline (dict)
        Returns:
            Returns a cursor to iterate on model objects
        """
        dbclient = DBClient.getInstance()
        pipeline["type"] = "computer"
        ds = dbclient.findInDb(pentest, cls.coll_name, pipeline, True)
        if ds is None:
            return None
        for d in ds:
            # disabling this error as it is an abstract function
            yield cls(pentest, d)  # Â pylint: disable=no-value-for-parameter
    
    @classmethod
    def fetchObject(cls, pentest, pipeline):
        """Fetch many commands from database and return a Cursor to iterate over model objects
        Args:
            pipeline: a Mongo search pipeline (dict)
        Returns:
            Returns a cursor to iterate on model objects
        """
        pipeline["type"] = "computer"
        dbclient = DBClient.getInstance()
        d = dbclient.findInDb(pentest, cls.coll_name, pipeline, False)
        if d is None:
            return None
        return cls(pentest, d)

    def update(self):
        return update(self.pentest, self._id, self.getData())
    
    def addInDb(self):
        return insert(self.pentest, self.getData())

    @classmethod
    def bulk_insert(self, pentest, computers_to_add):
        if not computers_to_add:
            return
        dbclient = DBClient.getInstance()
        dbclient.create_index(pentest, "computers", [("ip", 1), ("type", 1)])
        update_operations = []
        set_ip = set()
        for computer in computers_to_add:
            data = computer
            data["type"] = "computer"
            if "_id" in data:
                del data["_id"]
            updater = {"$set":{}}
            for s in list(data.keys()):
                if s.startswith("infos."):
                    updater["$set"][s] = data[s]
                    del data[s]
            if len(updater["$set"]) == 0:
                del updater["$set"]
            updater["$setOnInsert"] = data
            if data["ip"].strip() not in set_ip:
                update_operations.append(UpdateOne({"ip": data["ip"].strip(), "type": "computer"}, updater, upsert=True))
                set_ip.add(data["ip"].strip())
            else:
                if "$setOnInsert" in updater:
                    del updater["$setOnInsert"]
                if updater:
                    update_operations.append(UpdateOne({"ip": data["ip"].strip(), "type": "computer"}, updater, upsert=True))
        if not update_operations:
            return
        result = dbclient.bulk_write(pentest, "computers", list(update_operations))
        upserted_ids = result.upserted_ids
        if not upserted_ids and result.modified_count == 0:
            return
        computers_inserted = Computer.fetchObjects(pentest, {"type":"computer", "ip":{"$in":list(set_ip)}})
        for computer in computers_inserted:
            if computer.infos.is_dc:
                computer.add_dc_checks()
                computer.add_domain_checks()
            if computer.infos.is_sqlserver:
                computer.add_sqlserver_checks()
            domain = computer.domain
            if domain is not None:
                domain = domain.lower()
            if domain is not None and domain != "":
                existingDomain = dbclient.findInDb(pentest, 
                    "computers", {"type":"computer", "domain":domain.lower()}, False)
                if existingDomain is None:
                    computer.addCheck("AD:onNewDomainDiscovered", {"domain":domain.lower()})
        return upserted_ids

    @classmethod
    def getTriggers(cls):
        """
        Return the list of trigger declared here
        """
        return ["AD:onFirstUserOnDC", "AD:onFirstAdminOnDC",  "AD:onNewUserOnDC", "AD:onNewAdminOnDC", 
                            "AD:onFirstUserOnComputer", "AD:onFirstAdminOnComputer", "AD:onNewUserOnComputer", "AD:onNewAdminOnComputer",
                            "AD:onNewDomainDiscovered", "AD:onNewDC", "AD:onNewSQLServer","AD:onFirstUserOnSQLServer", "AD:onFirstAdminOnSQLServer"]


    @property
    def infos(self):
        """Gets the infos of this Computer.


        :return: The infos of this Computer.
        :rtype: ComputerInfos
        """
        return self._infos

    def checkAllTriggers(self):
        self.add_dc_checks()
        self.add_sqlserver_checks()
        self.add_user_checks()
        self.add_admin_checks()
        self.add_domain_checks()

    def add_domain_checks(self):
        if self.infos.is_dc:
            self.addCheck("AD:onNewDC", { "domain":self.domain})

    def add_dc_checks(self):
        if len(self.users) > 0:
            self.addCheck("AD:onFirstUserOnDC", {"user":self.users[0]})
        if len(self.admins) > 0:
            self.addCheck("AD:onFirstAdminOnDC", {"user":self.admins[0]})

    def add_sqlserver_checks(self):
        if self.infos.is_sqlserver:
            self.addCheck("AD:onNewSQLServer", { "domain":self.domain})
            if len(self.users) > 0:
                self.addCheck("AD:onFirstUserOnSQLServer", {"user":self.users[0]})
            if len(self.admins) > 0:
                self.addCheck("AD:onFirstAdminOnSQLServer", {"user":self.admins[0]})

    def add_user_checks(self):
        if len(self.users) == 1:
            if self.infos.is_dc:
                self.addCheck("AD:onFirstUserOnDC", {"user":self.users[-1]})
                self.addCheck("AD:onNewUserOnDC", {"user":self.users[-1]})
            if self.infos.is_sqlserver:
                self.addCheck("AD:onFirstUserOnSQLServer", {"user":self.users[-1]})
            self.addCheck("AD:onFirstUserOnComputer", {"user":self.users[-1]})
        if len(self.users) >= 1:
            find_user = None
            for user in self.users:
                user_o = User.fetchObject(self.pentest, {"_id":ObjectId(user)})
                if user_o.username != "" and user_o.password != "":
                    find_user = user_o.getId()
                    break
            if find_user is None:
                find_user = self.users[-1]
            self.addCheck("AD:onNewUserOnComputer", {"user":find_user})

    def add_admin_checks(self):
        if len(self.admins) == 1:
            if self.infos.is_dc:
                self.addCheck("AD:onFirstAdminOnDC", {"user":self.admins[-1]})
                self.addCheck("AD:onNewAdminOnDC", {"user":self.admins[-1]})
            if self.infos.is_sqlserver:
                self.addCheck("AD:onFirstAdminOnSQLServer", {"user":self.admins[-1]})
            self.addCheck("AD:onFirstAdminOnComputer", {"user":self.admins[-1]})
        if len(self.admins) >= 1:
            self.addCheck("AD:onNewAdminOnComputer", {"user":self.admins[-1]})

    @infos.setter
    def infos(self, infos):
        """Sets the infos of this Computer.


        :param infos: The infos of this Computer.
        :type infos: ComputerInfos
        """
        #keeping clarity with explicit checks
        if self.infos.get("is_dc", False) == False and infos.get("is_dc", False) == True:
            self.add_dc_checks()
        self._infos = infos

    def add_user(self, domain, username, password, infos=None):
        if infos is None:
            infos = {}
        user_m = User().initialize(self.pentest, None, domain, username, password, infos=infos)
        res = user_m.addInDb()
        if not res["res"]:
            user_m = User.fetchObject(self.pentest, {"_id":ObjectId(res["iid"])})
            user_m.updateInfos(infos)
        if str(res["iid"]) not in self.users and password.strip() != "":
            self.users.append(str(res["iid"]))
            self.add_user_checks()
        self.update()
        return str(res["iid"])

    def add_admin(self, domain, username, password):
        res_iid = self.add_user(domain, username, password)
        if res_iid not in self.admins:
            self.admins.append(res_iid)
            self.add_admin_checks()
        self.update()

    
    @classmethod
    def replaceCommandVariables(cls, pentest, command, data):
        command = command.replace("|domain|", "" if data.get("domain", "") is None else data.get("domain", ""))
        return command
        
    def addCheck(self, lvl, info):
        checks = CheckItem.fetchObjects({"lvl":lvl})
        if lvl in ["AD:onNewDomainDiscovered", "AD:onNewDC", "AD:onNewSQLServer"]:
            infos = {"domain":info.get("domain")}
        else:
            user_o = User.fetchObject(self.pentest, {"_id":ObjectId(info.get("user"))})
            if user_o is None:
                logger.error("User was not found when trying to add ActiveDirectory tool ")
                return
            username = user_o.username if user_o.username is not None else ""
            password = user_o.password if user_o.password is not None else ""
            domain = user_o.domain if user_o.domain is not None else ""
            infos = {"username":username, "password":password, "domain":domain}
        for check in checks:
            CheckInstance.createFromCheckItem(self.pentest, check, str(self._id), "computer", infos=infos)

@permission("pentester")
def delete(pentest, computer_iid):  # noqa: E501
    """Delete computer

    Delete an active Directory Computer # noqa: E501

    :param pentest: 
    :type pentest: str
    :param computer_iid: 
    :type computer_iid: str

    :rtype: Union[None, Tuple[None, int], Tuple[None, int, Dict[str, str]]
    """
    dbclient = DBClient.getInstance()
    share_dic = dbclient.findInDb(pentest, "computers", {"_id":ObjectId(computer_iid), "type":"computer"}, False)
    if share_dic is None:
        return 0
    res = dbclient.deleteFromDb(pentest, "computers", {"_id": ObjectId(computer_iid), "type":"computer"}, False)
    if res is None:
        return 0
    else:
        return res

@permission("pentester")
def update(pentest, computer_iid, body):  # noqa: E501
    """update computer

    Update an Active Directory computer # noqa: E501

    :param pentest: 
    :type pentest: str
    :param computer_iid: 
    :type computer_iid: str
    :param computer: 
    :type computer: dict | bytes

    :rtype: Union[None, Tuple[None, int], Tuple[None, int, Dict[str, str]]
    """
    computer = Computer(pentest, body) 
    dbclient = DBClient.getInstance()
    existing = Computer.fetchObject(pentest, {"_id": ObjectId(computer_iid)})
    if existing is None:
        return "not found", 404
    if computer.ip != existing.ip:
        return "Forbidden", 403
    if "type" in body:
        del body["type"]
    if "_id" in body:
        del body["_id"]
    domain = body.get("domain", None)
    if domain is not None:
        domain = domain.lower()
        body["domain"] = domain
    if domain is None or domain == "":
        return "Invalid domain", 400
    if domain is not None and domain != "":
        existingDomain = dbclient.findInDb(pentest, 
             "computers", {"type":"computer", "domain":domain}, False)
        if existingDomain is None:
            computer.addCheck("AD:onNewDomainDiscovered", {"domain":domain})
    if existing.infos.is_dc != computer.infos.is_dc:
        existing.add_dc_checks()
        existing.add_domain_checks()
    if existing.infos.is_sqlserver != computer.infos.is_sqlserver:
        existing.add_sqlserver_checks()

    dbclient.updateInDb(pentest, "computers", {"_id": ObjectId(computer_iid), "type":"computer"}, {"$set": body}, False, True)
    return True

@permission("pentester")
def insert(pentest, body):  # noqa: E501
    """insert computer

    Add an Active Directory computer # noqa: E501

    :param pentest: pentest name
    :type pentest: str
    :param computer: 
    :type computer: dict | bytes

    :rtype: Union[None, Tuple[None, int], Tuple[None, int, Dict[str, str]]
    """
    computer = Computer(pentest, body)
    dbclient = DBClient.getInstance()
    existing = dbclient.findInDb(pentest, 
        "computers", {"type":"computer", "ip":computer.ip}, False)
    if existing is not None:
        if body.get("infos", {}).get("is_dc", False) is True:
            existing["infos"]["is_dc"] = True
            dbclient.updateInDb(pentest, "computers", {"_id": existing["_id"]}, {"$set": {"infos": existing["infos"]}}, False, True)
            computer.add_dc_checks()
            computer.add_domain_checks()
        if body.get("infos", {}).get("is_sqlserver", False) is True:
            existing["infos"]["is_sqlserver"] = True
            dbclient.updateInDb(pentest, "computers", {"_id": existing["_id"]}, {"$set": {"infos": existing["infos"]}}, False, True)
            computer.add_sqlserver_checks()
        return {"res": False, "iid": existing["_id"]}
    if "_id" in body:
        del body["_id"]
    body["type"] = "computer"
    
    ins_result = dbclient.insertInDb(pentest, 
        "computers", body, True)
    if computer.infos.is_dc:
        computer.add_dc_checks()
        computer.add_domain_checks()
    if computer.infos.is_sqlserver:
        computer.add_sqlserver_checks()
    domain = body.get("domain", None)
    if domain is not None:
        domain = domain.lower()
        body["domain"] = domain
    if domain is not None and domain != "":
        existingDomain = dbclient.findInDb(pentest, 
             "computers", {"type":"computer", "domain":domain.lower()}, False)
        if existingDomain is None:
            computer.addCheck("AD:onNewDomainDiscovered", {"domain":domain.lower()})
    iid = ins_result.inserted_id
    return {"res": True, "iid": iid}

@permission("pentester")
def getUsers(pentest, computer_iid):
    dbclient = DBClient.getInstance()
    computer_m = Computer.fetchObject(pentest, {"_id":ObjectId(computer_iid)})
    if computer_m is None:
        return "Not found", 404
    users = dbclient.findInDb(pentest, "users", { "type":"user", "_id" : { "$in" : [ObjectId(x) for x in computer_m.users ]} } , multi=True)
    if users is None:
        users = []
    admins = dbclient.findInDb(pentest, "users", { "type":"user", "_id" : { "$in" : [ObjectId(x) for x in computer_m.admins ]} }, multi=True)
    if admins is None:
        admins = []
    return {"users":list(users), "admins":list(admins)}