# coding: utf-8

from __future__ import absolute_import
from bson import ObjectId
from pollenisator.core.components.mongo import DBClient
from pollenisator.core.components.logger_config import logger
from pollenisator.server.servermodels.element import ServerElement
from pollenisator.server.servermodels.command import ServerCommand
from pollenisator.server.servermodels.tool import ServerTool
from pollenisator.server.modules.cheatsheet.cheatsheet import CheckItem
from pollenisator.server.modules.activedirectory.computer_infos import ComputerInfos
from pollenisator.server.modules.activedirectory.users import User
from pollenisator.server.modules.cheatsheet.checkinstance import CheckInstance
from pollenisator.server.permission import permission

class Computer(ServerElement):
    coll_name = "ActiveDirectory"
    
    """NOTE: This class is was generated by OpenAPI Generator (https://openapi-generator.tech).
    """

    def __init__(self, pentest, valuesFromDb=None):
        if valuesFromDb is None:
            valuesFromDb = {}
        self.initialize(pentest, valuesFromDb.get("_id"),  valuesFromDb.get("name"), valuesFromDb.get("ip"), \
             valuesFromDb.get("domain"),  valuesFromDb.get("admins"),  valuesFromDb.get("users"), valuesFromDb.get("infos"))

    def initialize(self, pentest=None, _id=None, name=None, ip=None, domain=None, admins=None, users=None, infos=None):  # noqa: E501
        """Computer - a model defined in OpenAPI
        :param pentest: current pentest 
        :type pentest: str
        :param _id: iid of the object
        :type _id: str
        :param name: The name of this Computer.  # noqa: E501
        :type name: str
        :param ip: The ip of this Computer.  # noqa: E501
        :type ip: str
        :param domain: The domain of this Computer.  # noqa: E501
        :type domain: str
        :param admins: The admins of this Computer.  # noqa: E501
        :type admins: List[str]
        :param users: The users of this Computer.  # noqa: E501
        :type users: List[str]
        :param infos: The infos of this Computer.  # noqa: E501
        :type infos: ComputerInfos
        """

        self._id = _id
        self.name = name
        self.ip = ip
        self.domain = domain
        self.admins = admins
        self.users = users
        self._infos = ComputerInfos(infos)
        dbclient = DBClient.getInstance()
        if pentest != "":
            self.pentest = pentest
        elif dbclient.current_pentest != "":
            self.pentest = dbclient.current_pentest
        else:
            raise ValueError("An empty pentest name was given and the database is not set in mongo instance.")
    
    def __str__(self):
        """
        Get a string representation of a defect.

        Returns:
            Returns the defect +title.
        """
        return self.domain+"\\"+self.name + " ("+self.ip+")"

    def getData(self):
        return {"_id": self._id, "name":self.name, "ip":self.ip, "domain":self.domain,
            "admins":self.admins, "users": self.users, "infos":self.infos.getData()}

    @classmethod
    def fetchObjects(cls, pentest, pipeline):
        """Fetch many commands from database and return a Cursor to iterate over model objects
        Args:
            pipeline: a Mongo search pipeline (dict)
        Returns:
            Returns a cursor to iterate on model objects
        """
        dbclient = DBClient.getInstance()
        pipeline["type"] = "computer"
        ds = dbclient.findInDb(pentest, cls.coll_name, pipeline, True)
        if ds is None:
            return None
        for d in ds:
            # disabling this error as it is an abstract function
            yield cls(pentest, d)  # Â pylint: disable=no-value-for-parameter
    
    @classmethod
    def fetchObject(cls, pentest, pipeline):
        """Fetch many commands from database and return a Cursor to iterate over model objects
        Args:
            pipeline: a Mongo search pipeline (dict)
        Returns:
            Returns a cursor to iterate on model objects
        """
        pipeline["type"] = "computer"
        dbclient = DBClient.getInstance()
        d = dbclient.findInDb(pentest, cls.coll_name, pipeline, False)
        if d is None:
            return None
        return cls(pentest, d)

    def update(self):
        return update(self.pentest, self._id, self.getData())
    
    def addInDb(self):
        return insert(self.pentest, self.getData())

    @classmethod
    def getTriggers(cls):
        """
        Return the list of trigger declared here
        """
        return ["AD:onFirstUserOnDC", "AD:onFirstAdminOnDC",  "AD:onNewUserOnDC", "AD:onNewAdminOnDC", 
                            "AD:onFirstUserOnComputer", "AD:onFirstAdminOnComputer", "AD:onNewUserOnComputer", "AD:onNewAdminOnComputer",
                            "AD:onNewDomainDiscovered", "AD:onNewDC"]


    @property
    def infos(self):
        """Gets the infos of this Computer.


        :return: The infos of this Computer.
        :rtype: ComputerInfos
        """
        return self._infos

    def checkAllTriggers(self):
        self.add_dc_checks()
        self.add_user_checks()
        self.add_admin_checks()
        self.add_domain_checks()

    def add_domain_checks(self):
        if self.infos.is_dc:
            self.addCheck("AD:onNewDC", { "domain":self.domain})

    def add_dc_checks(self):
        if len(self.users) > 0:
            self.addCheck("AD:onFirstUserOnDC", {"user":self.users[0]})
        if len(self.admins) > 0:
            self.addCheck("AD:onFirstAdminOnDC", {"user":self.admins[0]})

    def add_user_checks(self):
        if len(self.users) == 1:
            if self.infos.is_dc:
                self.addCheck("AD:onFirstUserOnDC", {"user":self.users[-1]})
                self.addCheck("AD:onNewUserOnDC", {"user":self.users[-1]})
            self.addCheck("AD:onFirstUserOnComputer", {"user":self.users[-1]})
        if len(self.users) >= 1:
            self.addCheck("AD:onNewUserOnComputer", {"user":self.users[-1]})

    def add_admin_checks(self):
        if len(self.admins) == 1:
            if self.infos.is_dc:
                self.addCheck("AD:onFirstAdminOnDC", {"user":self.admins[-1]})
                self.addCheck("AD:onNewAdminOnDC", {"user":self.admins[-1]})
            self.addCheck("AD:onFirstAdminOnComputer", {"user":self.admins[-1]})
        if len(self.admins) >= 1:
            self.addCheck("AD:onNewAdminOnComputer", {"user":self.admins[-1]})

    @infos.setter
    def infos(self, infos):
        """Sets the infos of this Computer.


        :param infos: The infos of this Computer.
        :type infos: ComputerInfos
        """
        #keeping clarity with explicit checks
        if self.infos.get("is_dc", False) == False and infos.get("is_dc", False) == True:
            self.add_dc_checks()
        self._infos = infos

    def add_user(self, domain, username, password, infos=None):
        if infos is None:
            infos = {}
        user_m = User().initialize(self.pentest, None, domain, username, password, infos=infos)
        res = user_m.addInDb()
        if not res["res"]:
            user_m = User.fetchObject(self.pentest, {"_id":ObjectId(res["iid"])})
            user_m.updateInfos(infos)
        if str(res["iid"]) not in self.users and password.strip() != "":
            self.users.append(str(res["iid"]))
            self.add_user_checks()
        self.update()

    def add_admin(self, domain, username, password):
        user_m = User().initialize(self.pentest, None, domain, username, password)
        res = user_m.addInDb()
        if str(res["iid"]) not in self.admins:
            self.admins.append(str(res["iid"]))
            self.add_admin_checks()
        self.update()

    @classmethod
    def replaceCommandVariables(cls, pentest, command, data):
        command = command.replace("|domain|", data.get("domain", ""))
        return command
        
    def addCheck(self, lvl, info):
        checks = CheckItem.fetchObjects({"lvl":lvl})
        if lvl in ["AD:onNewDomainDiscovered", "AD:onNewDC"]:
            infos = {"domain":info.get("domain")}
        else:
            user_o = User.fetchObject(self.pentest, {"_id":ObjectId(info.get("user"))})
            if user_o is None:
                logger.error("User was not found when trying to add ActiveDirectory tool ")
                return
            username = user_o.username if user_o.username is not None else ""
            password = user_o.password if user_o.password is not None else ""
            domain = user_o.domain if user_o.domain is not None else ""
            infos = {"username":username, "password":password, "domain":domain}
        for check in checks:
            CheckInstance.createFromCheckItem(self.pentest, check, str(self._id), "computer", infos=infos)

@permission("pentester")
def delete(pentest, computer_iid):  # noqa: E501
    """Delete computer

    Delete an active Directory Computer # noqa: E501

    :param pentest: 
    :type pentest: str
    :param computer_iid: 
    :type computer_iid: str

    :rtype: Union[None, Tuple[None, int], Tuple[None, int, Dict[str, str]]
    """
    dbclient = DBClient.getInstance()
    share_dic = dbclient.findInDb(pentest, "ActiveDirectory", {"_id":ObjectId(computer_iid), "type":"computer"}, False)
    if share_dic is None:
        return 0
    res = dbclient.deleteFromDb(pentest, "ActiveDirectory", {"_id": ObjectId(computer_iid), "type":"computer"}, False)
    if res is None:
        return 0
    else:
        return res.deleted_count

@permission("pentester")
def update(pentest, computer_iid, body):  # noqa: E501
    """update computer

    Update an Active Directory computer # noqa: E501

    :param pentest: 
    :type pentest: str
    :param computer_iid: 
    :type computer_iid: str
    :param computer: 
    :type computer: dict | bytes

    :rtype: Union[None, Tuple[None, int], Tuple[None, int, Dict[str, str]]
    """
    computer = Computer(pentest, body) 
    dbclient = DBClient.getInstance()
    existing = Computer.fetchObject(pentest, {"_id": ObjectId(computer_iid)})
    if existing is None:
        return "not found", 404
    if computer.ip != existing.ip:
        return "Forbidden", 403
    if "type" in body:
        del body["type"]
    if "_id" in body:
        del body["_id"]
    domain = body.get("domain", None)
    if domain is not None:
        domain = domain.lower()
        body["domain"] = domain
    if domain is not None and domain != "":
        existingDomain = dbclient.findInDb(pentest, 
             "ActiveDirectory", {"type":"computer", "domain":domain}, False)
        if existingDomain is None:
            computer.addCheck("AD:onNewDomainDiscovered", {"domain":domain})
    if existing.infos.is_dc != computer.infos.is_dc:
        existing.add_dc_checks()
        existing.add_domain_checks()

    dbclient.updateInDb(pentest, "ActiveDirectory", {"_id": ObjectId(computer_iid), "type":"computer"}, {"$set": body}, False, True)
    return True

@permission("pentester")
def insert(pentest, body):  # noqa: E501
    """insert computer

    Add an Active Directory computer # noqa: E501

    :param pentest: pentest name
    :type pentest: str
    :param computer: 
    :type computer: dict | bytes

    :rtype: Union[None, Tuple[None, int], Tuple[None, int, Dict[str, str]]
    """
    computer = Computer(pentest, body)
    dbclient = DBClient.getInstance()
    existing = dbclient.findInDb(pentest, 
        "ActiveDirectory", {"type":"computer", "ip":computer.ip}, False)
    if existing is not None:
        return {"res": False, "iid": existing["_id"]}
    if "_id" in body:
        del body["_id"]
    body["type"] = "computer"
    domain = body.get("domain", None)
    if domain is not None:
        domain = domain.lower()
        body["domain"] = domain
    if domain is not None and domain != "":
        existingDomain = dbclient.findInDb(pentest, 
             "ActiveDirectory", {"type":"computer", "domain":domain.lower()}, False)
        if existingDomain is None:
            computer.addCheck("AD:onNewDomainDiscovered", {"domain":domain.lower()})
    ins_result = dbclient.insertInDb(pentest, 
        "ActiveDirectory", body, True)
    

    iid = ins_result.inserted_id
    return {"res": True, "iid": iid}

@permission("pentester")
def getUsers(pentest, computer_iid):
    dbclient = DBClient.getInstance()
    computer_m = Computer.fetchObject(pentest, {"_id":ObjectId(computer_iid)})
    if computer_m is None:
        return "Not found", 404
    users = dbclient.findInDb(pentest, "ActiveDirectory", { "type":"user", "_id" : { "$in" : [ObjectId(x) for x in computer_m.users ]} } , multi=True)
    if users is None:
        users = []
    admins = dbclient.findInDb(pentest, "ActiveDirectory", { "type":"user", "_id" : { "$in" : [ObjectId(x) for x in computer_m.admins ]} }, multi=True)
    if admins is None:
        admins = []
    return {"users":list(users), "admins":list(admins)}