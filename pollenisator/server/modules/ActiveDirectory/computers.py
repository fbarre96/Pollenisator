# coding: utf-8

from __future__ import absolute_import
from bson import ObjectId
from pollenisator.core.Components.mongo import MongoCalendar
from pollenisator.core.Components.logger_config import logger
from pollenisator.server.ServerModels.Element import ServerElement
from pollenisator.server.ServerModels.Command import ServerCommand
from pollenisator.server.ServerModels.Tool import ServerTool
from pollenisator.server.modules.ActiveDirectory.computer_infos import ComputerInfos
from pollenisator.server.modules.ActiveDirectory.users import User
from pollenisator.server.permission import permission

class Computer(ServerElement):
    coll_name = "ActiveDirectory"
    
    """NOTE: This class is was generated by OpenAPI Generator (https://openapi-generator.tech).
    """

    def __init__(self, pentest, valuesFromDb=None):
        if valuesFromDb is None:
            valuesFromDb = {}
        self.initialize(pentest, valuesFromDb.get("_id"),  valuesFromDb.get("name"), valuesFromDb.get("ip"), \
             valuesFromDb.get("domain"),  valuesFromDb.get("admins"),  valuesFromDb.get("users"), valuesFromDb.get("infos"))

    def initialize(self, pentest=None, _id=None, name=None, ip=None, domain=None, admins=None, users=None, infos=None):  # noqa: E501
        """Computer - a model defined in OpenAPI
        :param pentest: current pentest 
        :type pentest: str
        :param _id: iid of the object
        :type _id: str
        :param name: The name of this Computer.  # noqa: E501
        :type name: str
        :param ip: The ip of this Computer.  # noqa: E501
        :type ip: str
        :param domain: The domain of this Computer.  # noqa: E501
        :type domain: str
        :param admins: The admins of this Computer.  # noqa: E501
        :type admins: List[str]
        :param users: The users of this Computer.  # noqa: E501
        :type users: List[str]
        :param infos: The infos of this Computer.  # noqa: E501
        :type infos: ComputerInfos
        """

        self._id = _id
        self.name = name
        self.ip = ip
        self.domain = domain
        self.admins = admins
        self.users = users
        self._infos = ComputerInfos(infos)
        mongoInstance = MongoCalendar.getInstance()
        if pentest != "":
            self.pentest = pentest
        elif mongoInstance.calendarName != "":
            self.pentest = mongoInstance.calendarName
        else:
            raise ValueError("An empty pentest name was given and the database is not set in mongo instance.")
    
    def getData(self):
        return {"_id": self._id, "name":self.name, "ip":self.ip, "domain":self.domain,
            "admins":self.admins, "users": self.users, "infos":self.infos.getData()}

    @classmethod
    def fetchObjects(cls, pentest, pipeline):
        """Fetch many commands from database and return a Cursor to iterate over model objects
        Args:
            pipeline: a Mongo search pipeline (dict)
        Returns:
            Returns a cursor to iterate on model objects
        """
        mongoInstance = MongoCalendar.getInstance()
        pipeline["type"] = "computer"
        ds = mongoInstance.findInDb(pentest, cls.coll_name, pipeline, True)
        if ds is None:
            return None
        for d in ds:
            # disabling this error as it is an abstract function
            yield cls(pentest, d)  # Â pylint: disable=no-value-for-parameter
    
    @classmethod
    def fetchObject(cls, pentest, pipeline):
        """Fetch many commands from database and return a Cursor to iterate over model objects
        Args:
            pipeline: a Mongo search pipeline (dict)
        Returns:
            Returns a cursor to iterate on model objects
        """
        pipeline["type"] = "computer"
        mongoInstance = MongoCalendar.getInstance()
        d = mongoInstance.findInDb(pentest, cls.coll_name, pipeline, False)
        if d is None:
            return None
        return cls(pentest, d)

    def update(self):
        return update(self.pentest, self._id, self.getData())
    
    def addInDb(self):
        return insert(self.pentest, self.getData())


    @property
    def infos(self):
        """Gets the infos of this Computer.


        :return: The infos of this Computer.
        :rtype: ComputerInfos
        """
        return self._infos

    @infos.setter
    def infos(self, infos):
        """Sets the infos of this Computer.


        :param infos: The infos of this Computer.
        :type infos: ComputerInfos
        """
        #keeping clarity with explicit checks
        if self.infos.get("is_dc", False) == False and infos.get("is_dc", False) == True:
            if len(self.users) > 0:
                self.addTool("AD:onFirstUserOnDC", {"user":self.users[0]})
            if len(self.admins) > 0:
                self.addTool("AD:onFirstAdminOnDC", {"user":self.admins[0]})
        self._infos = infos

    def add_user(self, domain, username, password):
        user_m = User().initialize(self.pentest, None, domain, username, password)
        res = user_m.addInDb()
        if str(res["iid"]) not in self.users and password.strip() != "":
            self.users.append(str(res["iid"]))
            if len(self.users) == 1:
                if self.infos.is_dc:
                    self.addTool("AD:onFirstUserOnDC", {"user":self.users[-1]})
                    self.addTool("AD:onNewUserOnDC", {"user":self.users[-1]})
                self.addTool("AD:onFirstUserOnComputer", {"user":self.users[-1]})
            self.addTool("AD:onNewUserOnComputer", {"user":self.users[-1]})
            
        self.update()

    def add_admin(self, domain, username, password):
        user_m = User().initialize(self.pentest, None, domain, username, password)
        res = user_m.addInDb()
        if str(res["iid"]) not in self.admins:
            self.admins.append(str(res["iid"]))
            if len(self.admins) == 1:
                if self.infos.is_dc:
                    self.addTool("AD:onFirstAdminOnDC", {"user":self.admins[-1]})
                    self.addTool("AD:onNewAdminOnDC", {"user":self.admins[-1]})
                self.addTool("AD:onFirstAdminOnComputer", {"user":self.admins[-1]})
            self.addTool("AD:onNewAdminOnComputer", {"user":self.admins[-1]})
        self.update()
        
    def addTool(self, lvl, info):
        commands = ServerCommand.fetchObjects({"lvl":lvl}, targetdb=self.pentest)
        if lvl == "AD:onNewDomainDiscovered":
            infos = {"domain":info.get("domain")}
        else:
            user_o = User.fetchObject(self.pentest, {"_id":ObjectId(info.get("user"))})
            if user_o is None:
                logger.error("User was not found when trying to add ActiveDirectory tool ")
                return
            username = user_o.username if user_o.username is not None else ""
            password = user_o.password if user_o.password is not None else ""
            domain = user_o.domain if user_o.domain is not None else ""
            infos = {"username":username, "password":password, "domain":domain}
        mongoInstance = MongoCalendar.getInstance()
        wave_d = mongoInstance.findInDb(self.pentest, "waves", {"wave":{"$ne":"Imported"}}, False)
        for command in commands:
            newTool = ServerTool(self.pentest)
            newTool.initialize(command.getId(), wave=wave_d["wave"],
                            ip=self.ip, port="445", proto="tcp", lvl=lvl, infos=infos)
            newTool.addInDb()

@permission("pentester")
def delete(pentest, computer_iid):  # noqa: E501
    """Delete computer

    Delete an active Directory Computer # noqa: E501

    :param pentest: 
    :type pentest: str
    :param computer_iid: 
    :type computer_iid: str

    :rtype: Union[None, Tuple[None, int], Tuple[None, int, Dict[str, str]]
    """
    mongoInstance = MongoCalendar.getInstance()
    share_dic = mongoInstance.findInDb(pentest, "ActiveDirectory", {"_id":ObjectId(computer_iid), "type":"computer"}, False)
    if share_dic is None:
        return 0
    res = mongoInstance.deleteFromDb(pentest, "ActiveDirectory", {"_id": ObjectId(computer_iid), "type":"computer"}, False)
    if res is None:
        return 0
    else:
        return res.deleted_count

@permission("pentester")
def update(pentest, computer_iid, body):  # noqa: E501
    """update computer

    Update an Active Directory computer # noqa: E501

    :param pentest: 
    :type pentest: str
    :param computer_iid: 
    :type computer_iid: str
    :param computer: 
    :type computer: dict | bytes

    :rtype: Union[None, Tuple[None, int], Tuple[None, int, Dict[str, str]]
    """
    computer = Computer(pentest, body) 
    mongoInstance = MongoCalendar.getInstance()
    existing = Computer.fetchObject(pentest, {"_id": ObjectId(computer_iid)})
    if computer.ip != existing.ip:
        return "Forbidden", 403
    if "type" in body:
        del body["type"]
    if "_id" in body:
        del body["_id"]
    domain = body.get("domain", None)
    if domain is not None:
        domain = domain.lower()
        body["domain"] = domain
    if domain is not None and domain != "":
        existingDomain = mongoInstance.findInDb(pentest, 
             "ActiveDirectory", {"type":"computer", "domain":domain}, False)
        if existingDomain is None:
            computer.addTool("AD:onNewDomainDiscovered", {"domain":domain})
    if existing.infos.is_dc != computer.infos.is_dc:
        if existing.users:
            existing.addTool("AD:onFirstUserOnDC", {"user":existing.users[-1]})
        for user in existing.users:
            existing.addTool("AD:onNewUserOnDC", {"user":user[-1]})

    mongoInstance.updateInDb(pentest, "ActiveDirectory", {"_id": ObjectId(computer_iid), "type":"computer"}, {"$set": body}, False, True)
    return True

@permission("pentester")
def insert(pentest, body):  # noqa: E501
    """insert computer

    Add an Active Directory computer # noqa: E501

    :param pentest: pentest name
    :type pentest: str
    :param computer: 
    :type computer: dict | bytes

    :rtype: Union[None, Tuple[None, int], Tuple[None, int, Dict[str, str]]
    """
    computer = Computer(pentest, body)
    mongoInstance = MongoCalendar.getInstance()
    existing = mongoInstance.findInDb(pentest, 
        "ActiveDirectory", {"type":"computer", "ip":computer.ip}, False)
    if existing is not None:
        return {"res": False, "iid": existing["_id"]}
    if "_id" in body:
        del body["_id"]
    body["type"] = "computer"
    domain = body.get("domain", None)
    if domain is not None:
        domain = domain.lower()
        body["domain"] = domain
    if domain is not None and domain != "":
        existingDomain = mongoInstance.findInDb(pentest, 
             "ActiveDirectory", {"type":"computer", "domain":domain.lower()}, False)
        if existingDomain is None:
            computer.addTool("AD:onNewDomainDiscovered", {"domain":domain.lower()})
    ins_result = mongoInstance.insertInDb(pentest, 
        "ActiveDirectory", body, True)
    

    iid = ins_result.inserted_id
    return {"res": True, "iid": iid}

@permission("pentester")
def getUsers(pentest, computer_iid):
    mongoInstance = MongoCalendar.getInstance()
    computer_m = Computer.fetchObject(pentest, {"_id":ObjectId(computer_iid)})
    if computer_m is None:
        return "Not found", 404
    users = mongoInstance.findInDb(pentest, "ActiveDirectory", { "type":"user", "_id" : { "$in" : [ObjectId(x) for x in computer_m.users ]} } , multi=True)
    if users is None:
        users = []
    admins = mongoInstance.findInDb(pentest, "ActiveDirectory", { "type":"user", "_id" : { "$in" : [ObjectId(x) for x in computer_m.admins ]} }, multi=True)
    if admins is None:
        admins = []
    return {"users":list(users), "admins":list(admins)}